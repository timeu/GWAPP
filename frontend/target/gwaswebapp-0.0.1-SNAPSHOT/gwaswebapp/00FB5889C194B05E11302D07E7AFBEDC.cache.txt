[
"/* @pjs transparent=\"true\"; */  \nint fps = 1;\nString data_raw = null;\nGenomeBrowser browser = null;\nLayout layout = null;\n\n\nvar eventHandler = {};\n \nvoid setup()\n{\n   frameRate(fps);\n   smooth();\n   layout = new Layout(width,height);\n   browser = new GenomeBrowser(\"\");\n   noLoop();\n}\n\n\nvoid draw()\n{\n    background(255)\n    background(0,0,0,0);\n    browser.render();     \n}\n\n\n// API for access via javascript\n\nvoid api_setSize(int width,int height) {\n    size(width,height);\n    layout.setSize(width,height);\n}\n\nvoid api_addEventHandler(String handler,callback)\n{\n    eventHandler[handler] = callback;\n}\n\n\nvoid api_clearEventHandlers()\n{\n   eventHandler = {};\n}\n\nvoid api_setViewRegion(int start, int end)\n{\n	if (end - start > 0)\n	{\n		layout.setViewRegion(start,end);\n		draw();\n	}\n}\n\nvoid api_setLength(int length)\n{\n  api_setViewRegion(0,length);\n}\n \nvoid api_setChromosome(String chr)\n{\n	browser.chr = chr;\n}\n\nvoid api_setShowRangeSelector(int showRangeSelector) {\n    layout.setShowRangeSelector(showRangeSelector);\n}\n\nint api_getLength()\n{\n    return layout.getViewLength();\n}\n\nint api_getZoomStart(){\n    return layout.zoomStart;\n}\n\nint api_getZoomEnd() {\n    return layout.zoomEnd;\n}\n\nint api_getViewStart() {\n   return layout.viewStart;\n}\n\nint api_getViewEnd() {\n	return layout.viewEnd;\n}\n\nint api_getMaximumZoomToDraw() {\n    return layout.maximumZoomToDraw;\n}\n\nvoid api_setMaximumZoomToDraw(int maximumZoomToDraw) {\n    layout.maximumZoomToDraw = maximumZoomToDraw;\n}\n\nint api_getMaximumZoomToDrawFeatures() {\n    return layout.maximumZoomToDrawFeatures;\n}\n\nvoid api_setMaximumZoomToDrawFeatures(int maximumZoomToDrawFeatures) {\n    layout.maximumZoomToDrawFeatures = maximumZoomToDrawFeatures;\n}\n\nvoid api_updateZoom(int start, int end)\n{\n    layout.updateZoom(start,end);\n    draw();\n}\n\nvoid api_setSelectionLine(int position)\n{\n     layout.mousePositionX  = layout.bpToPx(position - layout.zoomStart) + layout.area.x;\n     draw();\n}\n\nvoid api_hideSelectionLine()\n{\n    api_setSelectionLinePx(-1);\n    draw();\n}\n\nvoid api_setSelectionLinePx(int position_px)\n{\n     layout.mousePositionX = position_px;\n}\n\nvoid api_redraw(boolean isFetchGenes) {\n     if (isFetchGenes)\n     	layout.fetchGenes();\n     else\n     	draw();\n}\n\nvoid api_setGeneData(geneData)\n{\n    if (layout.maximumZoomToDraw == -1 || layout.getZoomLength() <= layout.maximumZoomToDraw )\n    {\n        ArrayList genes = new ArrayList();   \n        for (int i =0;i<geneData.length;i++)\n        {\n        	ArrayList geneInfo = geneData[i];\n        	ArrayList cds = new ArrayList();\n        	ArrayList utrs = new ArrayList();\n        	for (int j = 0;j<geneInfo[4].length;j++)\n        	{\n        		ArrayList featureInfo = geneInfo[4][j];\n        		if (featureInfo[3] == \"CDS\")\n        			cds.add(new CDS(featureInfo[0],featureInfo[1]));\n        		else if (featureInfo[3] == \"five_prime_UTR\")\n        		    utrs.add(new UTR5(featureInfo[0],featureInfo[1]));\n        		else if (featureInfo[3] == \"three_prime_UTR\")\n        		    utrs.add(new UTR3(featureInfo[0],featureInfo[1]));\n        	}\n        	String strand = \"+\";\n        	if (geneInfo[2] == -1) \n        		strand = \"-\";\n        	Gene gene = new Gene(geneInfo[3],geneInfo[3],\"TestGene\",strand,geneInfo[0],geneInfo[1],cds,utrs);\n        	genes.add(gene);\n        }\n    	browser.setGenes(genes);\n    	draw();\n    }\n}\n\n\n// Classes\n\n\nclass DrawArea\n{\n   int x;\n   int y;\n   int width;\n   int height;\n  \n   \n   DrawArea(x,y,width,height)\n   {\n      this.x = x;\n      this.y = y;\n      this.width = width;\n      this.height = height;\n   }\n   \n   int getEndPosX()\n   {\n      return x + width;\n   } \n   int getEndPosY()\n   {\n      return y + height;\n   }\n}\n\n\n// Responsible for the layout\nclass Layout\n{\n   // Width of browser in px\n   int width;\n   // Height of browser in px\n   int height;\n   // start of zoom area in bp\n   int zoomStart = 0;\n   // end of zoom area in bp\n   int zoomEnd = 0;\n   \n   int viewStart = 0;\n   \n   int viewEnd = 0;\n   \n   \n   \n   //color settings\n   int highlightedGeneColor= #007EFF;\n   //#FFCC00;\n   int selectionLineColor = #007EFF;\n   \n   //int marginLeft = 26;\n   //int marginRight = 5;\n   int marginLeft = 0;\n   int marginRight = 0;\n   int marginTop = 0;\n   int marginBottom = 0;\n   \n   // default Height of genes and cds in px\n   int cdsHeight = 12;\n   int utrHeight = 7;\n   int geneLineWeight = 4;\n      \n   // mosuePositions\n   float mousePositionX = -1;\n   float mousePositionY = -1;\n   \n   // which mouse Button is Pressed\n   int mouseButtonPressed = -1;\n   int mouseButtonPressedX = -1;\n   \n   int labelScaleSize = 12;\n\n   DrawArea area = null;\n   \n   float pxPerBp=1; \n   float absolutePxPerBp=1;\n\n   //where to display scale (0 = no display, 1 = bottom, 2 = top)\n   int showScale = 1;\n   \n   // where to display range selector (0 = no display, 1 = bottom, 2 = top)\n   int showRangeSelector = 1;\n   int rangeSelectorHeight=40;\n   int rangeSelectorGridCount = 10;\n\n   // how many vertical grid lines should be drawn\n   int gridLineCount = 5;\n   \n   int maximumZoomToDraw = 1500000;\n   \n   int maximumZoomToDrawFeatures = 100000;\n   \n   boolean isZoomUpdating = false;\n   \n   int laneCount = 0;\n   int laneSize = 0;\n   int activeLane = 0;\n   int laneMarginTop = 20;\n   PFont font = new PFont(\"Arial\");\n   \n   int [] lanes = null;\n   \n   \n   \n   Layout(width,height)\n   {\n       zoomEnd = viewEnd;\n       setSize(width,height);\n   }\n   \n   void setSize(int width,int height) {\n   	   this.width = width;\n       this.height = height;\n       initArea();\n       initPxPerBb();\n       initLanes();\n   }\n   \n   void initLanes()\n   {\n   	   int scale = 2;\n   	   if (getZoomLength() <= maximumZoomToDrawFeatures)\n   	      scale = 3;\n       laneSize = cdsHeight*scale;\n   	   laneCount = floor((this.area.height-getLaneMarginTop()) / laneSize);\n   	   lanes = new int[laneCount];\n   	   resetLanes();\n   }\n   \n   void resetLanes()\n   {\n   	   for (int i =0;i<laneCount;i++)\n   	   {\n   	   		lanes[i] = -1;\n   	   }\n   }\n   \n   void setShowRangeSelector(showRangeSelector) {\n   	     this.showRangeSelector = showRangeSelector; \n   	     initLanes();\n   	     draw();\n   }\n   \n   void initArea()\n   {\n        this.area = new DrawArea(marginLeft,marginTop,(width - marginLeft - marginRight),(height - marginTop - marginBottom));\n   }\n   \n   void setViewRegion(int start, int end)\n   {\n       /*if (zoomStart == 0)\n       	   zoomStart = start;\n   	   else if (zoomStart < start)\n   	       zoomStart = start;\n   	   if (zoomEnd == 0)\n   	       zoomEnd = end;\n   	   else if (zoomEnd > end)\n   	       zoomEnd = end;\n   	   */\n   	   zoomStart = start;\n   	   zoomEnd = end;\n       viewStart = start;\n       viewEnd = end;\n       initPxPerBb();\n       fetchGenes();\n   }\n\n   void initPxPerBb()\n   {\n       if (this.zoomEnd - this.zoomStart != 0)\n       	  this.pxPerBp  = (float)this.area.width / (this.zoomEnd - this.zoomStart);\n       if (this.viewEnd - this.viewStart != 0)\n          this.absolutePxPerBp = (float)this.area.width / (this.viewEnd - this.viewStart);\n   }\n   \n   void getFreeLane(x)  {\n       for (int i = 0;i<laneCount;i++)\n       {\n       		if (lanes[i] < x)\n       			return i;\n       }\n       return 0;\n   }\n   \n   PVector getPixelPosition(int start, int end) {\n   	  start = (start - this.zoomStart);\n      if (start < 0)\n      	  start = 0;\n      \n      //calculate end;	  \n      end = (end - zoomStart);\n      if (end > zoomEnd)\n      	   end = zoomEnd;\n	   PVector vector = new PVector(round(layout.bpToPx(start)) + area.x,round(layout.bpToPx(end)) + area.x);\n	   return vector;\n   }\n   \n   int getLaneMarginTop() {\n       int top = laneMarginTop;\n       if (showRangeSelector != 0)\n           top = top + rangeSelectorHeight;\n       return top;\n   }\n   \n   int getLanePosY(int lane)\n   {\n   		return area.y + laneMarginTop + (lane*laneSize);\n   }\n   \n   int getViewLength() \n   {\n      return viewEnd - viewStart;\n   }\n   \n   int getLaneFromYPos(int y_px) {\n   	   return round((y_px - area.y - laneMarginTop)/laneSize)\n   }\n   \n   int getLowerLanePosY(int lane) {\n       int y_pos = getLanePosY(lane+1);\n       return y_pos + utrHeight;\n   }\n\n   PVector[] getPositions(int start, int end,String type,int lane)\n   {\n      float startY;\n      float endY;\n      int y_pos = getLanePosY(lane);\n      \n      // calculate start \n      int startX = (start - this.zoomStart);\n      if (startX < 0)\n      	  startX = 0;\n      \n      //calculate end;	  \n      int endX = (end - zoomStart);\n      if (endX > zoomEnd)\n      	   endX = zoomEnd;\n      \n      int startX_px = startX*pxPerBp + area.x;\n      int endX_px = endX*pxPerBp + area.x;\n      PVector [] positions = new PVector[2];\n      if (type ==\"line\")\n      {\n        startY = y_pos  ;\n        endY = y_pos ;\n      }\n      else if (type == \"utr\")\n      {\n          startY = y_pos-(utrHeight/2);\n          endY = y_pos + (utrHeight/2);\n      }\n      else if (type == \"text\")\n      {\n          startY = y_pos + utrHeight;\n          endY = startY;\n      }\n      else \n      {\n          startY = y_pos - (cdsHeight/2);\n          endY = y_pos + (cdsHeight/2);\n       }\n      positions[0] = new PVector(round(startX_px),startY);\n      positions[1] = new PVector(round(endX_px),endY);\n      return positions;\n   }\n   \n   PVector[] getStrandArrowPositions(int pos,String strand, int lane)\n   {\n       int y_pos = getLanePosY(lane);\n       PVector [] positions = new PVector[3];\n       float x_tip;\n       if (strand == \"+\")\n          x_tip = bpToPx(pos-zoomStart) + area.x + cdsHeight;\n       else\n          x_tip = bpToPx(pos-zoomStart) + area.x - cdsHeight;\n       positions[0] = new PVector(round(bpToPx(pos-zoomStart))+area.x,y_pos - (cdsHeight/2));\n       positions[1] = new PVector(round(bpToPx(pos-zoomStart))+area.x,y_pos + (cdsHeight/2));\n       positions[3] = new PVector(round(x_tip),y_pos);\n       return positions;   \n   }\n\n   int getGridLineBpSeperation()\n   {\n       return (int)(zoomEnd - zoomStart)/gridLineCount;\n   }\n   \n   int getRangeSelectorGridLineBpSeperation()\n   {\n       return (int)(viewEnd - viewStart)/rangeSelectorGridCount;\n   }\n   \n   int getRangeSelectorHeight() {\n       int currentHeight= 0;\n       if (showRangeSelector != 0)\n            currentHeight = rangeSelectorHeight;\n       return currentHeight;\n   }\n\n\n   float pxToBp(float pixel)\n   {\n      return (float) pixel / pxPerBp;\n   }\n\n   float bpToPx(int bp)\n   {\n      return pxPerBp * bp;\n   }\n   \n   float absolutebpToPx(int bp) {\n       return absolutePxPerBp*bp;\n   }\n   \n   float absolutepxToBp(float pixel) {\n       return (float) pixel / absolutePxPerBp;\n   }\n   \n   int getGenomePosition(int position_px )\n   {\n   		return round(pxToBp(position_px-area.x) + zoomStart);\n   }\n   \n   int getGenomePositionFromMouse()\n   {\n       return getGenomePosition(mousePositionX);\n   }\n   \n   void updateZoom(int start,int end)\n   {\n      if (end < start)\n      {\n         end_tmp = end;\n         end = start;\n         start = end_tmp;\n      }\n      if (start < viewStart)\n      	  start = viewStart;\n      if (end > viewEnd)\n         end = viewEnd;\n      zoomStart = start;\n      zoomEnd = end;\n      initPxPerBb();\n      fetchGenes();\n   }\n   \n   void fetchGenes()\n   {\n      \n      if (maximumZoomToDraw == -1 || getZoomLength() <= maximumZoomToDraw)\n      {\n          if (eventHandler['fetchGeneEvent'] != null)\n              eventHandler['fetchGeneEvent'](zoomStart,zoomEnd);\n      }\n   }\n   \n   void calculateZoom()\n   {\n      int start_px = mouseButtonPressedX - area.x;\n      int end_px = mouseX - area.x;\n      if (mouseButtonPressedX > mouseX)\n      {\n          start_px = mouseX- area.x;\n          end_px = mouseButtonPressedX - area.x;\n      }\n      if (start_px < 0) \n         start_px = 0;\n      if (end_px > area.getEndPosX())\n          end_px = area.getEndPosX();\n      \n      newZoomEnd = round(pxToBp(end_px)) + zoomStart;\n      newZoomStart = round(pxToBp(start_px)) + zoomStart;\n      updateZoom(newZoomStart,newZoomEnd);\n   }\n   \n   void moveZoomWindow(int direction)\n   {\n      int moveRatio_px = round(width*0.05);\n      int moveRatio = round(pxToBp(moveRatio_px));\n\n      if (direction > 0) \n         moveRatio = 0 - moveRatio;\n         \n      if (zoomStart + moveRatio < viewStart)\n         moveRatio = -1*zoomStart;\n      if (zoomEnd + moveRatio > viewEnd)\n         moveRatio = viewEnd - zoomEnd;\n      if ((zoomStart + moveRatio) >= viewStart && (moveRatio + zoomStart <= viewEnd))\n      {\n        zoomStart = zoomStart + moveRatio;\n        zoomEnd = zoomEnd + moveRatio;\n      }\n      fetchGenes();\n   }\n   \n   void convertToReadableBp(bp)\n   {\n   		String bp_converted = \"\";\n        if (bp > 1000000)\n           bp_converted = round(bp/1000000*1000)/1000 + \" Mb\";\n        else if (bp > 1000)\n           bp_converted = round(bp/1000*10)/10 + \" Kb\";\n        else \n           bp_converted = bp +\" b\";\n       return bp_converted;\n   }\n   \n   void resetZoom()\n   {\n      zoomStart = viewStart;\n      zoomEnd = viewEnd;\n      initPxPerBb();\n      browser.setGenes(new ArrayList());\n      fetchGenes();\n   }\n   int getZoomLength()\n   {\n       return zoomEnd - zoomStart;\n   }\n   \n   boolean isDrawFeatureZoomLevel() {\n   	  if (layout.maximumZoomToDrawFeatures == -1 || layout.getZoomLength() <= layout.maximumZoomToDrawFeatures)\n   	      return true;\n   	  return false;\n   }\n   \n   boolean checkSelectionLineInRange(int start, int end)\n   {\n   		if (mousePositionX != -1) \n        {\n        	int selectionLinePos = layout.getGenomePositionFromMouse();\n        	if (selectionLinePos >= start && selectionLinePos <= end)\n        	   return true;\n   		}\n   		return false;\n   }	\n}\n\n\n\nclass GenomeBrowser\n{\n   String chr;\n   ArrayList genes = null; \n   Gene highlightGene = null;\n   \n   GenomeBrowser(String chr)\n   {\n       this.chr = chr;\n   }\n\n   void render()\n   {\n        renderControls();\n        renderRangeSelector();\n        if (genes != null)\n        {\n            for (int i = 0;i<genes.size();i++)\n            {\n                Gene gene = genes.get(i);\n                gene.render();\n            }\n        }\n        renderZoomArea();\n        renderSelectionLine();\n   }\n   \n   \n   \n   \n   void renderZoomArea()\n   {\n       if(layout.mouseButtonPressed ==LEFT)\n       {\n           fill(100,30);\n           rectMode(CORNERS);\n           int startPosition = layout.mouseButtonPressedX;\n           if (startPosition < layout.area.x)\n               startPosition = layout.area.x;\n           else if (startPosition > layout.area.getEndPosX())\n               startPosition = layout.area.getEndPosX();\n           int endPosition = layout.mousePositionX;\n           if (endPosition  < layout.area.x)\n               endPosition = layout.area.x;\n           else if (endPosition > layout.area.getEndPosX())\n               endPosition = layout.area.getEndPosX();\n           rect(startPosition,layout.area.y+10,endPosition,layout.area.getEndPosY()-layout.labelScaleSize - layout.getRangeSelectorHeight());\n           fill(100);\n           String Position = round(layout.pxToBp(startPosition-layout.area.x) + layout.zoomStart);\n           String zoomWidth = layout.convertToReadableBp(Math.abs(round(layout.pxToBp(startPosition-layout.area.x) - layout.pxToBp(endPosition))));\n           if ((layout.mouseButtonPressedX - layout.area.x - textWidth(Position)) >0)\n              textAlign(RIGHT,BASELINE);\n           else \n              textAlign(LEFT,BASELINE);\n           text(Position,layout.mouseButtonPressedX,10);\n           text(zoomWidth,startPosition +  Math.abs((endPosition-startPosition)/2)+textWidth(zoomWidth)/2,layout.area.getEndPosY()-layout.labelScaleSize - layout.getRangeSelectorHeight());\n       }\n   }\n   \n   void renderSelectionLine()\n   {\n      if (layout.mousePositionX != -1 && layout.mouseButtonPressed != RIGHT)\n      {\n\n          if (layout.mousePositionX < layout.area.x)\n             layout.mousePositionX = layout.area.x;\n          else if (layout.mousePositionX > layout.area.getEndPosX())\n             layout.mousePositionX = layout.area.getEndPosX();\n             \n          stroke(layout.selectionLineColor);\n          line(layout.mousePositionX+0.5,layout.area.y,layout.mousePositionX+0.5,layout.area.height-layout.labelScaleSize - layout.getRangeSelectorHeight());\n          fill(layout.selectionLineColor);\n          String Position =  layout.getGenomePositionFromMouse();\n          if ((layout.mousePositionX + textWidth(Position) < layout.area.getEndPosX()))\n              textAlign(LEFT,TOP);\n          else\n              textAlign(RIGHT,TOP);\n          text(Position,layout.mousePositionX+0.5,0);\n      }\n   }\n   \n   void renderRangeSelector() {\n   \n       if (layout.showRangeSelector != 0) {\n       		 int scaleLineY = 0;\n        	 int scaleTextY = 0;\n        	 int gridLineSeperation = layout.getRangeSelectorGridLineBpSeperation();\n        	 float gridLineSeperationPx = layout.absolutebpToPx(gridLineSeperation);\n        	 if (layout.showRangeSelector == 1) {\n        	 	scaleTextY = layout.area.getEndPosY();\n        	 	scaleLineY = scaleTextY -  layout.labelScaleSize;\n        	 }\n        	 else\n        	 {\n        		scaleTextY = layout.area.getStartPosY();\n        		scaleLineY = scaleTextY +  layout.labelScaleSize;\n        	 }\n        	 fill(0);  \n        	 stroke(150);\n        	 textFont(layout.font,layout.labelScaleSize);\n        	 textAlign(LEFT,BASELINE);\n        	 \n        	 for (int i =0;i<=layout.rangeSelectorGridCount;i++)\n       		 {\n            	int x =  round(i*gridLineSeperationPx + layout.area.x)+0.5;\n            	line(x,scaleLineY,x,scaleLineY-2);\n            	text(round(layout.viewStart + i*gridLineSeperation),x,scaleTextY);\n        	 }\n        	 line(layout.area.x,scaleLineY+0.5,layout.area.getEndPosX(),scaleLineY+0.5);\n        	 \n        	 fill(100,20);\n             noStroke();\n             rectMode(CORNERS);\n                 \n			 int y_startPosition = scaleLineY -layout.getRangeSelectorHeight()+layout.labelScaleSize;\n			 int y_endPosition = scaleLineY;\n             int l_startPosition = 0;\n             int l_endPosition = layout.absolutebpToPx(layout.zoomStart);\n                 \n                 \n			 rect(l_startPosition,y_startPosition,l_endPosition,y_endPosition);\n			 int r_startPosition = layout.absolutebpToPx(layout.zoomEnd);\n			 int r_endPosition = layout.area.getEndPosX();\n			 rect(r_startPosition,y_startPosition,r_endPosition,y_endPosition);\n             stroke(100);\n             strokeWeight(2.2);\n             line(l_startPosition,y_startPosition,\n             l_endPosition,y_startPosition);\n             line(r_startPosition,y_startPosition,\n             r_endPosition,y_startPosition);\n             line(l_endPosition,y_startPosition,l_endPosition,y_endPosition);\n             line(r_startPosition,y_startPosition,r_startPosition,y_endPosition);\n             line(l_endPosition,y_endPosition,r_startPosition,y_endPosition);\n             strokeWeight(1);      \n       }\n   }\n\n   void renderControls()\n   {\n        //render scale\n        int scaleLineY = 0;\n        int scaleTextY = 0;\n        int gridLineSeperation = layout.getGridLineBpSeperation();\n        float gridLineSeperationPx = layout.bpToPx(gridLineSeperation);\n        if (layout.showScale == 1)\n        {\n           scaleTextY = layout.area.getEndPosY() - layout.getRangeSelectorHeight();\n           scaleLineY = scaleTextY - layout.labelScaleSize;\n\n        }\n        else\n        {\n           scaleTextY = layout.area.getEndPosY() - layout.getRangeSelectorHeight();\n           scaleLineY = scaleTextY + layout.labelScaleSize;\n        }\n        fill(0);  \n        stroke(150);\n        textFont(layout.font,layout.labelScaleSize);\n        textAlign(LEFT,BASELINE);\n\n        for (int i =0;i<=layout.gridLineCount;i++)\n        {\n            int x =  round(i*gridLineSeperationPx + layout.area.x)+0.5;\n            line(x,0,x,(layout.height- layout.getRangeSelectorHeight()));\n            text(round(layout.zoomStart + i*gridLineSeperation),x,scaleTextY);\n        }\n        line(layout.area.x,scaleLineY+0.5,layout.area.getEndPosX(),scaleLineY+0.5);\n   } \n\n   void setGenes(ArrayList genes)\n   {\n       this.genes = genes;\n       layout.initLanes();\n   }\n   \n   Gene getGeneFromPosition(int position,int lane)\n   {\n       if (genes != null)\n       {\n            for (int i = 0;i<genes.size();i++)\n            {\n                Gene gene = genes.get(i);\n                if (gene.lane == lane && gene.start <= position && gene.end >= position)\n                {\n                	return gene;\n                } \n            }\n        }\n        return null;\n   }\n   \n   void loadGeneData(String raw_data)\n   {\n       console.log(raw_data);\n   }\n   \n}\n\n\n\nclass Gene\n{\n   String strand;\n   int start;\n   int end;\n   String id;\n   String name;\n   String description;\n   ArrayList cds = new ArrayList();\n   ArrayList utrs = new ArrayList();\n   int lane = -1;\n\n   Gene(String id, String name,String description,String strand,int start,int end, ArrayList cds,ArrayList utrs)\n   {\n       this.id = id;\n       this.name = name;\n       this.description = description;\n       this.strand = strand;\n       this.start = start;\n       this.end = end;\n       this.cds = cds;\n       this.utrs = utrs;\n   }\n\n   void render()\n   {\n      // render Line\n      PVector vector = layout.getPixelPosition(start,end);\n      int start_x = vector.x;\n      int end_x = vector.y;\n      if (strand == \"-\") \n          start_x = start_x - layout.cdsHeight;\n      else \n          end_x = vector.y + layout.cdsHeight;\n      \n      if (layout.isDrawFeatureZoomLevel())\n      {\n      	 int nameWidth =  (int)textWidth(name);\n      	 if ((vector.x + nameWidth) > end_x) {\n       	 	end_x = vector.x + nameWidth;\n       	 }\n      }\n      \n      // get Lane\n      if (lane == -1)\n      {\n	      lane = layout.getFreeLane(start_x);\n	      layout.lanes[lane] = end_x;\n	  }\n	  \n	  boolean isSelectionLineInRange = layout.checkSelectionLineInRange(start, end);\n	  \n      renderGeneLine(isSelectionLineInRange);\n      \n      \n      if (layout.isDrawFeatureZoomLevel())\n      {\n	      for (int i = 0;i<utrs.size();i++)\n	      {\n	          UTR utr = utrs.get(i);\n	          utr.render(lane,isSelectionLineInRange);\n	      }\n	      for (int i = 0;i<cds.size();i++)\n	      {\n	          CDS cdsItem = cds.get(i);\n	          cdsItem.render(lane,isSelectionLineInRange);\n	      }\n	  }\n      renderStrandArrow(isSelectionLineInRange);\n      renderName(isSelectionLineInRange);\n      \n   }\n   \n   \n   void renderName(boolean isSelectionLineInRange)\n   {\n       if (!layout.isDrawFeatureZoomLevel())\n           return;\n       PVector[] positions = layout.getPositions(start,end,\"text\",lane);\n       PVector startPosition = (PVector)positions[0];\n       int color = layout.selectionLineColor \n       textAlign(LEFT,TOP);\n       if (isSelectionLineInRange)\n       	  color = #FF0000;\n       fill(color);\n       if (startPosition.x > 0)\n       {\n          text(name,startPosition.x,startPosition.y);\n       }\n       \n   }\n   void renderGeneLine(boolean isSelectionLineInRange)\n   {\n        PVector[] positions = layout.getPositions(start,end,\"line\",lane);\n        PVector startPosition = (PVector)positions[0];\n        PVector endPosition = (PVector)positions[1];\n        \n        int strokeColor = 0;\n       \n        if (isSelectionLineInRange && !layout.isDrawFeatureZoomLevel()) \n       	    strokeColor = layout.highlightedGeneColor;\n        \n        stroke(strokeColor);\n        strokeWeight(layout.geneLineWeight);\n        strokeCap(SQUARE);\n        line(startPosition.x,startPosition.y+0.5,endPosition.x,endPosition.y+0.5);\n        strokeWeight(1);\n        stroke(0);\n   }\n   \n   void renderStrandArrow(boolean isSelectionLineInRange)\n   {\n         float pos;\n         if (strand == \"+\")\n             pos = end;\n         else \n             pos = start;\n         PVector[] positions = layout.getStrandArrowPositions(pos,strand,lane);\n         //println(positions);\n         int fillColor = 100;\n         if (isSelectionLineInRange && !layout.isDrawFeatureZoomLevel())\n         	fillColor = layout.highlightedGeneColor; \n         fill(fillColor);\n         triangle(positions[0].x,positions[0].y,positions[1].x,positions[1].y,positions[3].x,positions[3].y);\n         fill(0);\n   }\n   \n}\n\n\nclass GeneFeature\n{\n   int start;\n   int end;\n   color c;\n   \n   GeneFeature(int start,int end)\n   {\n      this.start = start;\n      this.end = end;\n   }\n}\n\nclass UTR extends GeneFeature\n{\n\n  UTR(int start,int end)\n  {\n     super(start,end);\n  }\n  void render(int lane,boolean isSelectionLineInRange)\n  {\n       PVector[] positions = layout.getPositions(start,end,\"utr\",lane);\n       PVector startPosition = (PVector)positions[0];\n       PVector endPosition = (PVector)positions[1];\n       fill(c);\n       noStroke();\n       if (isSelectionLineInRange) \n       {\n       	   if (layout.checkSelectionLineInRange(start,end)) \n       	   {\n       	   	   stroke(layout.highlightedGeneColor);\n       	   	   strokeWeight(2);\n       	   }\n       }\n       strokeCap(SQUARE);\n       rectMode(CORNERS);\n       rect(startPosition.x,startPosition.y,endPosition.x,endPosition.y);\n       noStroke();\n       strokeWeight(1);\n   }\n  \n}\n\nclass UTR5 extends UTR\n{\n    UTR5(int start,int end)\n    {\n       super(start,end);\n       c = #ABF000;\n    }\n}\n\nclass UTR3 extends UTR\n{\n    UTR3(int start,int end)\n    {\n       super(start,end);\n       c = #00BD39;\n    }\n}\n\nclass CDS extends GeneFeature\n{\n    CDS(int start,int end)\n    {\n       super(start,end);\n       c = #FF8100;\n    }\n    \n   void render(int lane,boolean isSelectionLineInRange)\n   {\n       PVector[] positions = layout.getPositions(start,end,\"cds\",lane);\n       PVector startPosition = (PVector)positions[0];\n       PVector endPosition = (PVector)positions[1];\n       noStroke();\n       if (isSelectionLineInRange) \n       {\n       	   if (layout.checkSelectionLineInRange(start,end)) \n       	   {\n       	   	   stroke(layout.highlightedGeneColor);\n       	   	   strokeWeight(2);\n       	   }\n       }\n       fill(c);\n       strokeCap(SQUARE);\n       rectMode(CORNERS);\n       rect(startPosition.x,startPosition.y,endPosition.x,endPosition.y);\n       noStroke();\n       strokeWeight(1);\n   }\n}\n\nvoid mouseOut() {\n   if (eventHandler['unhighlightGeneEvent'] != null)\n   {\n   	   eventHandler['unhighlightGeneEvent']();\n   }\n}\n	\nvoid mouseMoved() {\n   layout.mousePositionX = mouseX;\n   layout.mousePositionY = mouseY;\n   if (!layout.isZoomUpdating)\n   {\n	   int position = layout.getGenomePositionFromMouse();\n	   boolean isUnhighlight = false;\n	   boolean isHighlight = false;\n	   Gene gene = browser.getGeneFromPosition(position,layout.getLaneFromYPos(mouseY));\n	   \n	   if (gene == null && browser.highlightGene!= null)\n	   {\n	       isUnhighlight = true;\n	   }\n	   else if (gene != null && gene != browser.highlightGene)\n	   {\n	   	   isHighlight = true;\n	   }\n	   \n	   browser.highlightGene = gene;\n	     \n	   if (eventHandler['mouseMoveEvent'] != null)\n	       eventHandler['mouseMoveEvent'](position);\n	   if (eventHandler['highlightGeneEvent'] != null && isHighlight && browser.highlightGene != null)\n	   {\n	   	   eventHandler['highlightGeneEvent'](browser.highlightGene,browser.chr,layout.mousePositionX,layout.getLowerLanePosY(gene.lane));\n	   }\n	   \n	   if (eventHandler['unhighlightGeneEvent'] != null && isUnhighlight)\n	   {\n	   	   eventHandler['unhighlightGeneEvent']();\n	   }\n   }\n   draw();  \n}\n\nvoid mouseDragged() {\n  layout.mousePositionX = mouseX;\n  if (layout.mousePositionX != layout.mouseButtonPressed)\n  {\n  	  layout.isZoomUpdating = true;\n  }\n  if (mouseButton == RIGHT)\n  {\n     layout.moveZoomWindow(mouseX - layout.mouseButtonPressedX);\n     if (eventHandler['zoomResizeEvent'] != null)\n       	  eventHandler['zoomResizeEvent'](layout.zoomStart,layout.zoomEnd);\n  }\n  draw();\n}\n\nvoid mouseReleased()\n{\n   boolean isZoomResized = false; \n   if (layout.mouseButtonPressed == LEFT && layout.isZoomUpdating)\n   {\n       layout.calculateZoom();\n       isZoomResized = true;\n   }\n   else if (layout.mouseButtonPressed == LEFT) \n   {\n        int position = layout.getGenomePositionFromMouse();\n   		Gene gene = browser.getGeneFromPosition(position,layout.getLaneFromYPos(mouseY));\n   		if (gene != null && eventHandler['clickGeneEvent'] != null)\n   		{\n   		    eventHandler['clickGeneEvent'](gene,browser.chr);\n   		 }\n   }\n   else if (layout.mouseButtonPressed == CENTER) \n   {\n	    layout.resetZoom();\n	    isZoomResized = true;\n   }\n   layout.mouseButtonPressed = -1;\n   layout.mouseButtonPressedX = -1;\n   layout.isZoomUpdating = false;\n   draw();\n   if (isZoomResized)\n   {\n   	 if (eventHandler['zoomResizeEvent'] != null)\n       	  eventHandler['zoomResizeEvent'](layout.zoomStart,layout.zoomEnd);\n   }\n}\n\nvoid mousePressed()\n{\n   	layout.mouseButtonPressed = mouseButton;\n   	layout.mouseButtonPressedX = mouseX;\n}\n\n\n\n\n\n"]